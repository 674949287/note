1.diff算法是虚拟DOM技术的必然产物：通过新旧虚拟DOM对比，将变化的地方更新到真实DOM上；另外，也需要diff高效的执行对比过程，从而使原本O（n3次方）降低时间复杂度为O（n）
2.vue2.x中为了降低Watcher粒度，每个组件中只有一个Watcher与之对应，只有引入diff才能精确找到变化的地方。
3.vue中diff执行的时刻是组件实例执行其更新函数时，它会对比上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。 //打补丁过程
这个时刻：（当我们修改一个数据的时候，由于vue的数据响应式触发了setter，setter会触发通知，会将watcher添加到异步更新队列，再每一次事件结束的时候会清空队列，清空队列过程中，所有的watcher会执行它们的更新函数，更新函数执行过程中，调用组件的渲染函数和组件的更新函数，重新渲染最新的虚拟DOM，执行更新函数，比较新旧的虚拟DOM）
4.diff过程整体遵循深度优先、同层比较的策略；两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；比较两组子节点是算法的重点，首先假设头尾两个节点可能相同做4此比对尝试，如果没有找到相同节点才按照通用方式遍历查找，查找结束再按照情况处理剩下节点；借助key通常可以非常精确找到相同节点，因此整个patch的过程非常高效。

理解：
1.先同级比较，在比较子节点
2.先判断一方有儿子一方没儿子的情况
3.比较都有儿子的情况
4.递归比较子节点

首先比较新旧虚拟dom的跟节点，如果相同把老的真实元素赋给新的
然后再去比较他们的儿子节点，如果都有儿子节点，则再比较他们的儿子节点
如果只有新的有儿子节点，老的虚拟dom没有，则把新增的儿子插入到老的虚拟dom中
如果老的有，新的没，就把老的儿子全部删除

属于一种双指针的比对方式
实际算法：先比较2个指针的起始点
1.尾部新增节点：2个指针从头同时移动，往后移动比较，直到不同来判断新增节点
2.头部新增节点：比较2个尾指针，往前比较，看是否新增节点是在头部
3.尾部节点移动到头部：用头指针，比较另一个尾指针，然后头指针往后移，尾指针往前移，来比较
4.头部节点移动到尾部：用尾指针，比较另一个头指针，然后头指针往后移，尾指针往前移，来比较
5.如果和原本都不一样：首个指针通过key，来找老的指针，如果找到了，则放在第一个，指针往后一个，在比较如果找到了，把老的节点移动到第二个，如果没有找到，则直接把该指针节点插入到该位置，然后指针往后移动，最后新指针移动完，老的如果还剩余，则把剩余的删除

